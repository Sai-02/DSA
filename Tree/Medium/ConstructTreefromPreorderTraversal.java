/*
Construct a binary tree of size N using 2 given arrays pre[] and preLN[]. 
Array pre[] represents preorder traversal of a binary tree. 
Array preLN[] has only two possible values ‘L’ and ‘N’
. The value ‘L’ in preLN[] indicates that 
the corresponding node in Binary Tree is a leaf node and 
value ‘N’ indicates that the corresponding node is a non-leaf node.
Note: Every node in the binary tree has either 0 or 2 children.

Example 1:

Input :      
N = 5
pre[] = {10, 30, 20, 5, 15}
preLN[] = {N, N, L, L, L}

Output:
          10
        /    \
      30      15
     /  \     
   20    5   
 

Your Task:  
You dont need to read input or print anything.
 Complete the function constructTree() which takes N, 
 pre[] and preLN[] as input parameters and 
 returns the root node of the constructed binary tree.
Note: The output generated by the compiler will contain the inorder traversal
 of the created binary tree.
 

Expected Time Complexity: O(N)
Expected Auxiliary Space: O(N)


Constraints:
1 ≤ N ≤ 104
1 ≤ pre[i] ≤ 107
preLN[i]: {'N', 'L'}
 */
// { Driver Code Starts
//Initial template for Java

import java.util.Scanner;
import java.lang.Math;
import java.io.*;

class Node {
    int data;
    Node left, right;

    Node(int d) {
        data = d;
        left = right = null;
    }
}

public class ConstructTreefromPreorderTraversal {
    public static void inorder(Node root) {
        if (root == null)
            return;
        inorder(root.left);
        System.out.print(root.data + " ");
        inorder(root.right);
    }

    public static void main(String args[]) throws IOException {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(read.readLine());
        while (t-- > 0) {
            int n = Integer.parseInt(read.readLine());

            String input_line1[] = read.readLine().trim().split("\\s+");
            int pre[] = new int[n];
            for (int i = 0; i < n; i++) {
                pre[i] = Integer.parseInt(input_line1[i]);
            }

            String input_line2[] = read.readLine().trim().split("\\s+");
            char preLN[] = new char[n];
            for (int i = 0; i < n; i++) {
                preLN[i] = input_line2[i].charAt(0);
            }
            Solution4 obj = new Solution4();
            Node root = obj.constructTree(n, pre, preLN);
            inorder(root);
            System.out.println();
        }
    }
}
// } Driver Code Ends

/*
 * class Node{ int data; Node left,right; Node(int d) { data=d; left=right=null;
 * } }
 */
class Solution4 {
    int i = 0;

    Node constructTree(int n, int pre[], char preLN[]) {
        i = 0;
        return solver(n, pre, preLN);
    }

    Node solver(int n, int pre[], char preLN[]) {
        if (i >= n) {
            return null;
        }
        Node newNode = new Node(pre[i]);
        if (preLN[i] == 'L') {
            return newNode;
        }
        i++;
        newNode.left = solver(n, pre, preLN);
        i++;
        newNode.right = solver(n, pre, preLN);
        return newNode;
    }
}

// ======================================
//
// GFG EDitorial
//
// =========================================

// The first element in pre[] will always be root.
//  So we can easily figure out root. 
//  If left subtree is empty,
//   the right subtree must also be empty and preLN[]
//    entry for root must be ‘L’. We can simply create a node and return it.
//     If left and right subtrees are not empty, 
//     then recursively call for left and right subtree
//      and link the returned nodes to root.



// class Solution
// {
//     public static int ind;
//     Solution(){ind=0;}

//     Node make(int pre[], char preLN[], int n){
//         if (ind == n)return null;
//         Node temp = new Node(pre[ind]);
//         ind++;
//         if(ind>=n)
//         return temp;
//         if (preLN[ind-1] == 'N')
//         {
//             temp.left = make(pre, preLN, n);
//             temp.right =make(pre, preLN, n);
//         }
//         return temp;
//     }

//     Node constructTree(int n, int pre[], char preLN[]){
//         return make(pre, preLN, n);
//     }
// }

